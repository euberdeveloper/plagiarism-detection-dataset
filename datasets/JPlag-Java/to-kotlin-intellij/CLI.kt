package de.jplag.cli

import picocli.CommandLine.Model.UsageMessageSpec.SECTION_KEY_FOOTER
import java.io.File
import java.security.SecureRandom
import java.util.*
import java.util.Set
import java.util.stream.Collectors
import kotlin.collections.HashSet
import kotlin.collections.List
import kotlin.collections.MutableList
import kotlin.collections.MutableSet
import kotlin.collections.forEach

/**
 * Command line interface class, allows using via command line.
 *
 * @see CLI.main
 */
class CLI {
    private val commandLine: CommandLine
    private val options: CliOptions

    /**
     * Creates a new instance
     */
    init {
        this.options = CliOptions()
        this.commandLine = CommandLine(options)

        commandLine.getHelpSectionMap().put(SECTION_KEY_OPTION_LIST) { help ->
            help.optionList().lines().map { it ->
                if (it.startsWith("  -")) {
                    return@map "    $it"
                } else {
                    return@map it
                }
            }.collect(Collectors.joining(System.lineSeparator()))
        }

        buildSubcommands().forEach(commandLine::addSubcommand)

        commandLine.getHelpSectionMap().put(SECTION_KEY_FOOTER) { help -> generateDescription() }
        commandLine.setAllowSubcommandsAsOptionParameters(true)
    }

    private fun buildSubcommands(): List<CommandSpec> {
        return LanguageLoader.getAllAvailableLanguages().values().stream().map { language ->
            val command: CommandSpec = CommandSpec.create().name(language.getIdentifier())
            for (option in language.getOptions().getOptionsAsList()) {
                command.addOption(
                    OptionSpec.builder(option.getNameAsUnixParameter()).type(option.getType().getJavaType())
                        .description(option.getDescription()).build()
                )
            }
            command.mixinStandardHelpOptions(true)
            command.addPositional(
                CommandLine.Model.PositionalParamSpec.builder().type(MutableList::class.java).auxiliaryTypes(
                    File::class.java
                ).hidden(true).required(false).build()
            )
            command
        }.toList()
    }

    /**
     * Parses the options from the given command line arguments. Also prints help pages when requested.
     *
     * @param args The command line arguments
     * @return the parse result generated by picocli
     */
    @Throws(CliException::class)
    fun parseOptions(vararg args: String?): ParseResult {
        try {
            val result: ParseResult = commandLine.parseArgs(args)
            if (result.isUsageHelpRequested() || (result.subcommand() != null && result.subcommand()
                    .isUsageHelpRequested())
            ) {
                commandLine.getExecutionStrategy().execute(result)
            }
            return result
        } catch (e: CommandLine.PicocliException) {
            throw CliException("Error during parsing", e)
        }
    }

    /**
     * Builds an options instance from parsed options.
     *
     * @return the newly built options
     */
    @Throws(CliException::class)
    fun buildOptionsFromArguments(parseResult: ParseResult): JPlagOptions {
        val submissionDirectories: MutableSet<File> = HashSet(
            java.util.List.of<File>(
                options.rootDirectory
            )
        )
        val oldSubmissionDirectories = Set.of<File>(options.oldDirectories)
        val suffixes = java.util.List.of<String>(options.advanced.suffixes)
        submissionDirectories.addAll(java.util.List.of(options.newDirectories))

        if (parseResult.subcommand() != null && parseResult.subcommand().hasMatchedPositional(0)) {
            submissionDirectories.addAll(parseResult.subcommand().matchedPositional(0).getValue())
        }

        val clusteringOptions: ClusteringOptions = getClusteringOptions(this.options)

        val jPlagOptions: JPlagOptions = JPlagOptions(
            loadLanguage(parseResult),
            options.minTokenMatch, submissionDirectories, oldSubmissionDirectories, null,
            options.advanced.subdirectory, suffixes,
            options.advanced.exclusionFileName, JPlagOptions.DEFAULT_SIMILARITY_METRIC,
            options.advanced.similarityThreshold,
            options.shownComparisons, clusteringOptions,
            options.advanced.debug
        )

        val baseCodePath: String = options.baseCode
        val baseCodeDirectory = if (baseCodePath == null) null else File(baseCodePath)
        if (baseCodeDirectory == null || baseCodeDirectory.exists()) {
            return jPlagOptions.withBaseCodeSubmissionDirectory(baseCodeDirectory)
        } else {
            logger.warn("Using legacy partial base code API. Please migrate to new full path base code API.")
            return jPlagOptions.withBaseCodeSubmissionName(baseCodePath)
        }
    }

    @Throws(CliException::class)
    private fun loadLanguage(result: ParseResult): Language {
        if (result.subcommand() != null) {
            val subcommandResult: ParseResult = result.subcommand()
            val language: Language = LanguageLoader.getLanguage(subcommandResult.commandSpec().name())
                .orElseThrow { CliException(IMPOSSIBLE_EXCEPTION) }
            val languageOptions: LanguageOptions = language.getOptions()
            languageOptions.getOptionsAsList().forEach { option ->
                if (subcommandResult.hasMatchedOption(option.getNameAsUnixParameter())) {
                    option.setValue(subcommandResult.matchedOptionValue(option.getNameAsUnixParameter(), null))
                }
            }
            return language
        } else {
            return options.language
        }
    }

    private fun generateDescription(): String {
        val randomDescription = DESCRIPTIONS[RANDOM.nextInt(DESCRIPTIONS.size)]
        return String.format("JPlag - %s%n%n%s", randomDescription, CREDITS)
    }

    val resultFolder: String
        get() = options.resultFolder

    companion object {
        private val logger: Logger = LoggerFactory.getLogger(CLI::class.java)

        private val RANDOM: Random = SecureRandom()

        private const val CREDITS =
            "Created by IPD Tichy, Guido Malpohl, and others. JPlag logo designed by Sandro Koch. Currently maintained by Sebastian Hahner and Timur Saglam."

        private val DESCRIPTIONS = arrayOf(
            "Detecting Software Plagiarism",
            "Software-Archaeological Playground",
            "Since 1996",
            "Scientifically Published",
            "Maintained by SDQ",
            "RIP Structure and Table",
            "What else?",
            "You have been warned!",
            "Since Java 1.0",
            "More Abstract than Tree",
            "Students Nightmare",
            "No, changing variable names does not work",
            "The tech is out there!",
            "Developed by plagiarism experts."
        )

        private const val IMPOSSIBLE_EXCEPTION =
            "This should not have happened." + " Please create an issue on github (https://github.com/jplag/JPlag/issues) with the entire output."

        /**
         * Main class for using JPlag via the CLI.
         *
         * @param args are the CLI arguments that will be passed to JPlag.
         */
        @JvmStatic
        fun main(args: Array<String>) {
            try {
                logger.debug("Your version of JPlag is {}", JPlag.JPLAG_VERSION)

                val cli = CLI()

                val parseResult: ParseResult = cli.parseOptions(*args)

                if (!parseResult.isUsageHelpRequested() && !(parseResult.subcommand() != null && parseResult.subcommand()
                        .isUsageHelpRequested())
                ) {
                    val options: JPlagOptions = cli.buildOptionsFromArguments(parseResult)
                    val result: JPlagResult = JPlag.run(options)
                    val reportObjectFactory: ReportObjectFactory = ReportObjectFactory()
                    reportObjectFactory.createAndSaveReport(result, cli.resultFolder)
                }
            } catch (exception: ExitException) {
                logger.error(exception.getMessage()) // do not pass exception here to keep log clean
                finalizeLogger()
                System.exit(1)
            }
        }

        private fun finalizeLogger() {
            val factory: ILoggerFactory = LoggerFactory.getILoggerFactory() as? CollectedLoggerFactory ?: return
            factory.finalizeInstances()
        }

        private fun getClusteringOptions(options: CliOptions): ClusteringOptions {
            var clusteringOptions: ClusteringOptions = ClusteringOptions().withEnabled(!options.clustering.disable)
                .withAlgorithm(options.clustering.enabled.algorithm)
                .withSimilarityMetric(options.clustering.enabled.metric)
                .withSpectralKernelBandwidth(options.clusterSpectralBandwidth)
                .withSpectralGaussianProcessVariance(options.clusterSpectralNoise)
                .withSpectralMinRuns(options.clusterSpectralMinRuns).withSpectralMaxRuns(options.clusterSpectralMaxRuns)
                .withSpectralMaxKMeansIterationPerRun(options.clusterSpectralKMeansIterations)
                .withAgglomerativeThreshold(options.clusterAgglomerativeThreshold)
                .withAgglomerativeInterClusterSimilarity(options.clusterAgglomerativeInterClusterSimilarity)

            if (options.clusterPreprocessingNone) {
                clusteringOptions = clusteringOptions.withPreprocessor(Preprocessing.NONE)
            }

            if (options.clusterPreprocessingCdf) {
                clusteringOptions = clusteringOptions.withPreprocessor(Preprocessing.CUMULATIVE_DISTRIBUTION_FUNCTION)
            }

            if (options.clusterPreprocessingPercentile !== 0) {
                clusteringOptions = clusteringOptions.withPreprocessor(Preprocessing.PERCENTILE)
                    .withPreprocessorPercentile(options.clusterPreprocessingPercentile)
            }

            if (options.clusterPreprocessingThreshold !== 0) {
                clusteringOptions = clusteringOptions.withPreprocessor(Preprocessing.THRESHOLD)
                    .withPreprocessorThreshold(options.clusterPreprocessingThreshold)
            }

            return clusteringOptions
        }
    }
}
